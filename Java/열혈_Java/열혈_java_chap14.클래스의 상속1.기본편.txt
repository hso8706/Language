*클래스의 상속_문법 이해

-상속
>목적
: 연관된 일련의 클래스들에 대해 공통적인 규약을 정의하기 위함.
//재활용을 위한 문법은 아니다
>선언
class NameB extends NameA{ ... }
: NameA 클래스를 NameB 클래스에 상속받는다
// 클래스 B에 클래스 A의 인스턴스 변수와 인스턴스 메소드가 존재한다.
// 하지만 클래스 B에 클래스 A의 인스턴스가 생성된 것은 아니다.
// 또한 클래스 A의 인스턴스 변수 혹은 메소드가 private으로 선언된 경우에는 클래스 B에 존재는 하지만 접근이 불가능하다.
// 상속을 도식화해서 생각하자면 상속받는 클래스가 상속할 클래스를 감싸는 느낌이다.
>특징
: 다중 상속은 불가능함.
: 자바는 단일 상속만 지원한다.

-상속 관련 용어 정리
>상위 클래스(=기초 클래스, 부모 클래스)
: 상속의 대상이 되는 클래스
: extends 뒤에 나오는 애.
>하위 클래스(=유도 클래스, 자식 클래스)
: 상속을 하는(받는) 클래스
: extends 앞에 나오는 애.
>상속의 UML 표현
: 표준화된 기호, 그림
: 채위진 화살표 대상이 상위(부모)클래스, 시작점이 하위(자식)클래스

-상속과 생성자
: 하위(자식)클래스의 생성자에 상위(부모)클래스의 변수의 초기화 내용을 추가해야한다. 
: 하지만 이처럼 연계적으로 초기화하는 방식은 좋지 않음. 생성자는 본인 클래스의 인스턴스가 생성될 때 초기화하는게 원칙이고 좋은 코드임. 따라서 이같은 방식은 작동은 되나 좋은 방법은 아님.
: 결론, 상위 클래스의 초기화 인자를 하위 클래스에서 받되, 상위 클래스 생성자를 호출하여 상위 클래스에서 초기화 되도록 할 것.

-상위 클래스 생성자 호출
>생성자 호출 관계
: 하위 클래스 생성자에서는 반드시 상위 클래스 생성자를 호출하게 되어 있음. 그것도 가장 먼저 호출해야함. (그렇지 않으면 컴파일러가 자동으로 호출 명령 작성)
>상위 클래스 생성자 호출 방법
super(var_name);
: super라는 명령어를 사용.
: 하위 클래스 생성자 내부 첫 줄에 위와 같은 상위 클래스 생성자를 호출하는 명령어를 적으면 됨.
: 인자는 상위 클래스에서 호출하려는 생성자의 매개변수와 같게 작성하면 된다.

-클래스 변수, 클래스 메소드와 상속간의 관계
: static 선언된 변수와 메소드는 단 하나만 존재하는 것이다. (그것도 static이 선언된 클래스 내에서만)
: 따라서, 상속이 되지 않는다.
: 하지만 접근에 대한 권한은 그대로 갖는다. 즉, 하위(자식)클래스에서도 . 연산자 없이도 변수, 클래스명만으로도 해당 클래스 변수, 클래스 메소드에 접근 가능하다. (단, private선언이 되지 않은 것에 한해서)
// NameA.methodA 이런 식으로 안쓰고, methodA로 바로 접근 가능하다는 것!