*제네릭의 기본 문법

-다중 매개변수 기반 제네릭 클래스의 정의
: T를 썼던 것을 기억.
: 빈 공간 < > 에 두 개의 문자를 쉼표( , )를 통해서 구분하여 넣기.

-타입 매개변수의 이름 규칙
>일반적인 관례
: 한 문자로 이름을 짓는다.
: 대문자로 이름을 짓는다.
>보편적인 예시
E : Element
K : Key
N : Number
T : Type
V : Value
: 이처럼 의미가 있는 단어를 함축해서 한 문자의 대문자로 작성.

-타입 인자에 대한 제한
: 타입 인자로는 클래스명이 와야한다.
: 즉, 기본 자료형(int, double 등)이 오면 컴파일 오류가 발생한다.
>래퍼 클래스의 활용
: 이러한 불편을 메꾸기 위해 Wrapper 클래스를 사용하고 자동 박싱, 언박싱 기능으로 대신할 수 있다.

-다이아몬드 기호, < >의 의미
: 인스턴스 생성시 대입 연산자 왼쪽< >안에 내용을 채우면, 대입 연산자 오른쪽 < >안의 내용은 생략해도 된다.

-'매개변수화 타입'을 '타입 인자'로 전달
: 즉, genericName<instanceType>를 통째로 타입 인자로 준다는 것.
: '매개변수화 타입'을 '타입 인자'로 전달하면, genericName<instanceType>가 참조하는 값을 넣을 수 있다.
>주의
: 매개변수화 타입을 타입 인자로 전달한만큼 가장 초기 매개변수화 타입의 변수가 가르키는 참조 값을 꺼내기 위해서는 같은 수 만큼 메소드를 호출해야 한다.

-제네릭 클래스의 타입 인자 제한하기
: 타입 매개변수에 상속 관계를 작성하면 해당 상속 관계에 있는 클래스만 타입 인자로 받을 수 있게 제한할 수 있음.
// 예시. class Box<T extends Number>
// : Number 클래스를 상속하는 클래스만 타입 인자로 쓸 수 있음.
>타입 인자 제한의 효과
: 다른 클래스들의 무분별한 유입을 제한할 수 있음.
: 더 중요한 것은 제네릭 클래스에 사용하는 메소드와 변수가 특정 클래스에서 호출가능한 경우에 사용된다.
// 예시. class Box<T>에 intValue메소드가 존재하면 에러가 발생된다.
// 예시. class Box<T extends Number>에 intValue메소드가 존재해도 에러가 발생되지 않는다.
: 즉, 타입 인자 제한을 통해서 제네릭 클래스에서 사용할 수 있는 메소드와 변수의 범위를 넓힐 수 있다.

-제네릭 클래스의 타입 인자를 인터페이스로 제한하기
: 타입 인자를 상속관계로 제한하는 것과 생김새가 똑같고 동일한 의미를 지닌다.
: extends를 사용한다.
: interface에 존재하는 메소드와 변수를 사용할 수 있다.

-하나의 클래스와 하나의 인터페이스에 대해 동시 제한
: 클래스의 상속과 인터페이스로 동시에 제한이 가능하다.
// class Box<T extends Class & Interface>

-제네릭 메소드의 정의
: 제네릭 클래스는 클래스 전체에 타입 매개변수를 지정한 것이다. 즉, 클래스 내부의 모든 자료형을 비운 것.
: 제네릭 메소드는 하나의 메소드의 자료형만 비우는 것.
>타입 매개변수의 위치
: 해당 메소드의 반환형 전에 타입 매개변수를 지정한다.
: 또한, 반환형, 매개 변수, 메소드 내부 등에 타입 인자가 들어올 자리에 모두 타입 매개변수를 지정한다.
>메소드의 제네릭 결정 시점
: 제네릭 메소드는 메소드가 호출될 때 결정된다.
: 즉, 제네릭 메소드를 호출 할 때, 타입 인자를 주어야한다.
>타입 인자의 생략
: 메소드에 주는 인자를 바탕으로 컴파일러가 자동으로 타입 인자를 결정하기 때문에 타입 인자를 굳이 쓰지 않아도 무관하다.

-제네릭 메소드의 제한된 타입 매개변수 선언
: 상속관계로 제네릭 클래스를 제한한 것과 똑같이 제네릭 메소드에 적용한 것이다.
: 효과 또한 동일하다.