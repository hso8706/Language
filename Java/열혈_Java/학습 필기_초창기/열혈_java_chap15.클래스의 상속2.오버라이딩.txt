*클래스의 상속2.오버라이딩

-상속을 위한 두 클래스의 관계
: extends만 이용하면 사실 문법적으로는 모든 클래스는 상속이 가능하다.
: 하지만 실제로는 그렇게 사용하지 않고 타당하지 않다.
: 상속에서는 논리적인 관계를 더 추구하는 것이 좋다.
>상속의 특성
: 하위 클래스는 상위 클래스의 모든 특성을 지닌다.
: 하위 클래스는 상위 클래스의 모든 특성에 추가로 자신만의 특성을 더하게 된다.
: 이처럼 연관된 기능을 가진 클래스 간 상속은 타당하다.
// is-a 관계
: A is a B, A는 일종의 B이다.
: 위 같은 관계가 상속의 후보가 된다.

-상속 관계에서 참조하는 경우의 수
M: 상위 클래스, 부모 클래스, mobile phone, 전화 기능
S: 하위 클래스, 자식 클래스, smart phone, 전화 기능+어플 기능
1. S s = new S; 가능
: 기존의 인스턴스 생성과 같음, S의 모든 기능 사용 가능
2. M m = new S; 가능
: 인스턴스가 더 큰 범위라면 참조 가능, 하지만 S의 일부 기능만 사용 가능(전화 기능, M에서 활용가능한 기능)
3. S s = new M; 불가능
: 인스턴스의 범위가 더 작기 때문에 참조 불가능
4. S s = new S; M m = s; 가능
5. M m = new S; S s = m; 불가능, 형변환 필요
>상속 관계에서 인스턴스와 참조형, 참조 변수
: 하위(자식) 클래스의 인스턴스를 모든 상위(부모) 클래스의 참조 변수로 참조 가능하다.
: 하지만 상위 클래스가 하위 클래스를 참조한 경우에는 상위 클래스의 기능 범위, 접근 권한까지만 사용 가능하다
: 반대(역)로는 불가능하다. 포함 범위(접근 권한)에 제한이 있기 때문에.
>참조변수의 참조 가능성: 배열 기반
1. S[ ] s = new S[n]; 가능
2. M[ ] m = new S[n]; 가능
: 상속의 영향력이 배열 인스턴스의 참조 관계까지 이어진다.

-메소드 오버라이딩,         매ㅐㅐㅐㅐㅐㅐ우 중요
>메소드 오버라이딩 정의
: 상속관계에서 메소드의 반환형, 이름, 매개변수가 같을 경우를 뜻함.
: 메소드 오버라이딩 당한 메소드를 가림.
: 점(.)찍고 접근이 불가능
>메소드 오버라이딩 관계
: 메소드 오버라이딩 관계에선 하위(자식)클래스의 메소드가 상위(부모)클래스의 메소드를 오버라이딩 했다고 표현
: 때문에 상위(부모)클래스 메소드 형 참조 변수로 메소드를 불러와도 하위(자식)클래스 메소드가 읽힘.
// M m = new S; m.call( ); 해당 call기능이 오버라이딩된 상태면 S의 call메소드가 읽힘. (원래는 M의 call만 읽을 수 있어야 했음)
>오버라이딩 된 메소드 호출 방법
super.method_name( );
: (오버라이딩 한 메소드를 가진)하위 클래스 내에서 위와 같은 문장으로 오버라이딩 된 메소드를 호출할 수 있음.
: 외부에선 호출할 수 없지만, 내부에서는 가능하다.
>인스턴스 변수와 클래스 변수도 오버라이딩이 되는가?
: 불가능, 참조 변수 형에 따라감
: 근데 이런식으로 변수명을 같게하는 것이 잘못된 코드임

-instanceof 연산자
>생김새
refVal_name instanceof ClassName
참조 변수명 instanceof 클래스명
>의미
: 참조 변수(클래스를 참조하는)를 ClassName의 참조형으로 참조가 가능한가?
: 즉 ClassName val = new ref_name ; 주어진 참조 변수의 형이 여기 우항에 들어갈 수 있는지를 확인하는 것.
>결과
: boolean값, 참조가 가능하면 true, 불가능하면 false
: 참조 변수(ref)가 ClassName 클래스의 인스턴스를 참조할 때, 그리고 상속하는 클래스의 인스턴스이면 true
>활용
: 사실 직접적으로 instanceof 연산자가 사용되는 경우는 적음
: 오버라이딩을 이용하면 코드가 더 가벼워지기 때문에