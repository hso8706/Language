*인터페이스와 추상 이론

-인터페이스
: 기능 활용 방법, 기능을 몰라도 활용할 수 있는 방법, 수단, 도구
: 인터페이스를 사용하는 목적은 확장성을 넓히기 위해서 인 듯 하다. (내피셜)
>선언
interface Name {
	public void method_name ( type var );
}
: interface라는 형을 가진 구조
: class와 비슷한 생김새 (내부에 메소드를 포함)
: 메소드는 몸체만 존재하는 추상 메소드
>특징
: 추상 메소드의 public 선언은 굳이 안해도 자동으로 public선언이 됨.
: 위는 인터페이스의 특징(원래는 default 선언이 정상)
: 변수에서는 public static final이 기본 선언(자동)
: 클래스가 아니므로 인스턴스의 생성은 불가능
: 하지만 참조 변수의 참조형으로는 사용 가능
>추상 메소드
: 선언부만 존재하고 몸체(내용)가 없음
: 인터페이스의 사용방법(버튼)에 해당되는 부분
>구현법(접근법)
: implements 명령어 사용
: 다른 클래스에서 인터페이스를 구현(접근)하여 클래스내에서 이를 완성시키는 작업을 한다.
: 상속과 생김새가 비슷하지만 아님.
: @Override 사용 가능

-인터페이스 상속
: 인터페이스 간 상속이 가능하다. (추가 메소드 설정 필요 시)
: extends 명령어 그대로 사용.
: 상속이 필요한 이유는 기존 메소드를 쓰는 장치는 그대로 두되 새로운 장치에만 새로운 메소드를 추가하기 위해서이다.

-인터페이스 디폴트 메소드
: 크게 중요하진 않으니 알아만 둘 것.
: 다양하고 광범위한(양이 많은) 인터페이스에 전부 추가 기능이 필요할 때, 사용하는 방법. (인터페이스의 수를 늘리지 않기 위함)
: 디폴트 메소드는 몸체(중괄호)가 존재하는 것이다.
: 디폴트 메소드를 각각의 인터페이스에 넣고 메소드의 실행을 하거나 실행을 하지 않거나 선택할 수 있게 하는 것이다.
>선언
default void name ( type var ) {  }; 

-인터페이스 대상의 instanceof 연산
: 표현은 다르지만, 의미는 같음
> ref_Name instanceof ClassName
: 클래스가 참조변수의 인터페이스를 직접 구현하거나, 간접적으로(상속관계로) 구현할 경우 true 반환
>인터페이스의 다른 용도: marker 인터페이스
: 인터페이스의 메소드가 아니라, 인터페이스 자체의 몸체(중괄호 내용)가 없음.
: instanceof 를 이용하여 인터페이스가 마킹된 것 중 골라서 실행시킬 수 있음.

-추상 클래스
: 클래스 내에서 추상 메소드 생성한 것.
: 추상 메소드란, 몸체가 없는 메소드
: 생성시 반환형 앞에 abstract를 써주면 됨.
: abstract를 씀으로써, 일부로 몸체가 없는 추상 메소드를 작성했다는 표시.
: 추상 메소드가 있는 클래스에도 class 앞에 abstract를 표현해야함.
: 클래스가 가능한 기능 모두 가능(참조 변수 선언, 인스턴스 변수, 인스턴스 메소드 등), 단 하나 빼고
: 인스턴스 생성이 불가능.
>추상 클래스 목적
: 개발자가 해당 클래스를 상위 클래스로만 두기 위해서 만든 클래스