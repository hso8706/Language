*정보 은닉 그리고 캡슐화

-정보 은닉
: 정보, 즉 인스턴스(클래스) 멤버를 가리는 것.
: 인스턴스 멤버에 접근할 때, 유저가 실수로 잘못된 접근을 시도할 수 있음. (논리적 오류)
: 하지만 이런 실수에 오류가 생기지 않기 때문에 큰 문제 (논리적 오류는 컴파일에서 오류를 발생하지 않음)
: 따라서, 인스턴스(클래스) 멤버 중 외부에서 사용될 필요가 없는 변수나 메소드는 숨길 필요가 있다! (논리적 오류를 문법적 오류로 바꿀 필요가 있다.)

-Setter, Getter
: 인스턴스(클래스)의 안전성을 높이기 위한 목적
: 매개변수와 반환값에 제한을 설정하기 위한 메소드
: 인스턴스에  private(정보 은닉)을 선언한 변수에 접근하기 위한 통호
>Setter, setName
: 인스턴스 변수의 값을 설정하는 용도로 정의된 메소드
: main에서 인스턴스로 값을 전달받기 위한 곳.
: 생성자에서 바로 값을 받는 것이 아니라, 생성자에서 세터로 전달 후 세터에서 값을 걸러 받게 할 수 있음.
: 세터 내에서 불필요한 데이터를 걸러낼 조건을 작성
>Getter, getName
: 인스턴스 변수의 값을 참조하는 용도로 정의된 메소드
: 인스턴스에서 main으로 값을 빼내는 곳

-Access-level Modifiers, 접근 수준 지시자
>종류
: public, protected, private, default
// public > protected > default > private
// 접근 허용 범위를 기준으로 구분
>선언 적용 대상
1. 클래스의 정의 대상
: public, default, 2가지만 가능
//public class의 경우, 두 가지 조건이 있음.
//1. 하나의 소스파일에 하나의 클래스만 public으로 선언
//2. 소스파일의 이름과 public으로 선언된 클래스의 이름을 일치시킨다.
2. 인스턴스 변수와 메소드 대상 (표로 정리하면 쉬움)
: public, protected, private, default, 4가지 모두 가능
>public
: 선언된 것을 어디서나 인스턴스 생성 혹은 접근 가능
>protected ( default +1 = private + 2 )
//상속(inheritance) : 다른 클래스를 해당 클래스로 끌어옴.
//다른 클래스의 멤버를 상속받은 클래스에서 사용할 수 있음.
//패키지와 상관없이 상속 가능
//하지만 패키지가 다른 경우에는 변수나 메소드를 불러오는데 제한이 존재. protected 선언이 된 것만 가능.
: default 선언이 허용하는 접근 모두 허용 (동일 클래스, 동일 패키지)
: 추가로 상속 관계로 이루어진 클래스 내에서 접근 허용
>default ( private + 1 )
: 동일 패키지로 묶은 클래스 내에서만 인스턴스 생성 혹은 접근 가능
: 범위, 동일 클래스+ 동일 패키지
: 아무런 선언이 없음.
>private
: 같은 클래스(인스턴스) 내에서만 접근 허용.

-캡슐화(Encapsulation)
: 하나의 목적을 위해, 한 클래스에 관련있는 모든 메소드와 변수를 담는 것을 의미함.
: 문법적인 내용은 아니지만 중요
>필요 기준
: 늘 같이 묶여 다니는 기능이거나, 그 기능들을 사용하는데 순서가 중요하다면 캡슐화 필요
>방법
1. 관련있는 각 클래스의 메소드나 변수를 한 클래스로 만드는것.
2. 관련있는 각 클래스를 그대로 두되, 이를 가르키는 하나의 클래스를 만들어 논리적으로 묶여있는 기능의 클래스를 만드는 것.