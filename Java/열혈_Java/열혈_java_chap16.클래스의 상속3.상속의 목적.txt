*클래스의 상속3. 상속의 목적

-상속 관계에서 기억해야할 요점
1. 상속 관계의 방향 (UML 표현)
2. 상속 관계에서 인스턴스와 참조형, 참조 변수의 가능 관계
3. 메소드 오버라이딩

-프로그래밍을 할 때 유념해야할 사항
1. 안정성, 안정적으로 프로그램이 실행되어야 함.
2. 확장성, 이후 추가 사항이 생길 때, 처음부터 다시 코드를 짜는 일이 없어야 함.
: 상속을 배우는 이유는 이 '확장성'에 연관이 있음.

-상속이 도움이 되는 상황
: 비슷한 관계에 있는 코드를 각자의 클래스로 구분하지 말고 상속 관계로 묶는다.
: 메소드 오버라이딩을 충분히 이용하면 확장성을 확보할 수 있다.
// 연관된 일련의 클래스들에 대해 공통적인 규약(부모 클래스)을 정의 및 적용할 수 있다!!

-Object 클래스와 final 선언 그리고 @Override

>모든 클래스는 Object 클래스를 상속합니다.
: java.lang.Object // java.lang 패키지에 존재하는 클래스
: extends를 통해 따로 상속을 안한 경우에는 자동으로 Object 클래스를 상속한다.
: extends를 통해 따로 상속을 한 경우에도 Object 클래스를 상속하는 부모 클래스가 존재한다.
: 가장 심연에 존재하는 부모 클래스는 Object 클래스이다
>Object 클래스를 상속하는 이유
: JVM(자바 가상머신)이 모든 클래스를 다루기 위해서 일련의 규칙인 Object 클래스를 상속(적용)시키는 것이다.
>예시
: Object o, 이처럼 Object형의 매개변수를 사용하면 어떤 메소드든 상관없이 매개변수로 사용할 수 있다.
: 그 예로, println 메소드 선언은
public void println(Object x) { ... }이다.
: 정의를 안하고 사용하는 메소드의 모든 Object메소드이거나 Object메소드를 오버라이딩한 메소드이다.

>클래스와 메소드의 final선언
: final 선언을 한 클래스는 다른 클래스가 상속할 수 없음.
: final 선언을 한 메소드는 다른 메소드가 오버라이딩 할 수 없음.

>@Override; Annotations Override
: 컴파일러에게 메소드 오버라이딩을 하고 있음을 알려주는 용어.
: 없어도 컴파일은 됨. 하지만 해당 용어를 썼을 때, 오버라이딩이 안되는 경우 에러를 제공함. 안정성을 확보할 수 있다.
: 해당 용어를 안 썼을 경우, 오버라이딩을 원했지만 실수로 안될 경우 원인을 파악 못 할 수 있음.
